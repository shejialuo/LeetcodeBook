\documentclass[../../main.tex]{subfiles}

\begin{document}

\setchapterpreamble[u]{\margintoc}

\chapter{双指针}

双指针是在算法中考察的很多的一类问题，其依赖于两个指针互相移动从而解决问题。
指针的移动方向可以相同，也可以相反，也可以是一前一后，这些都是根据具体问题而定的。

在我看来，这上面的话都是废话。并没有告诉你应该如何去实际的解决一个问题。这个章节主要
就是根据实际的问题来思考该如何使用双指针。

\section{N数和}

\subsection{\href{https://leetcode-cn.com/problems/two-sum/}{两数之和}}

几乎所有解决这个问题的方法都是使用哈希表，但是这里我们使用双指针来解决这个问题。
当我们解决了这个问题，我们才能继续地思考三数之和，四数之和等等问题。

这个题的暴力解法是显而易见的。如果要使用双指针解决这个问题，我们的做法就是排序，
然后使用两个指针分别指向数组的头和尾，然后根据两个指针指向的元素的和与目标值的
大小关系来移动指针。\sidenote{排序加双指针是一种常见的思想，通常用于解决需要在排序数组中找到
满足特定条件的元素对的问题}

在这个过程中，我们可以确定一个循环不变量：\textbf{在数组中，左侧指针之前的所有元素都小于等于
右侧指针之后的所有元素}。对指针\verb|start|和\verb|end|，我们可以得到其值

$$
sum = nums[start] + nums[end]
$$

如果$sum$小于目标值，那么我们就需要增大$sum$，所以我们需要增大\verb|start|，反之亦然。
我们可以简单地写出如下的代码：

\lstinputlisting[language=C++]{code/two_sum.cpp}
\sidenote{上述代码假设数组已经完成了排序}

\subsection{\href{https://leetcode-cn.com/problems/3sum}{三数之和}}

这个问题是上一个问题的升级版，我们需要找到所有的三元组，使得三元组的和为0。我们可以很简单地把这个
问题转化为两数之和的问题，即确定一个数，然后在剩下的数中找到两个数，使得这两个数的和为确定的数的
相反数。这个问题的难点在于如何去除重复的三元组。

首先，我们能够做一个最简单的去重思考。

\begin{example}
  假设$array = [1, -1, -1, -1, 2]$，当我们确定到$-1$时，我们可以得到一个唯一
  的三元组$(-1, -1, 2)$，当我们确定$-1$的下一个元素时，其也是$-1$，那么我们就会
  得到一个重复的三元组$(-1, -1, 2)$。因此我们需要跳过这个元素，直到我们确定的元素
  和上一个元素不一致。
\end{example}

上述的去重是我们不重复考虑一个相同的元素，但是我们还需要考虑一个问题，就是我们在确定两数之和
时，我们需要跳过相同的元素。

\begin{example}
  假设$array = [-2, -2, -2, -1, 0, 1, 2, 2, 2]$，我们套用两数之和的解法，开始时
  $start = 0, end = 8$。我们可以得到第一个解$(-2, 2)$，并且$start = 1, end = 7$，
  我们同时可以得到第二个解$(-2, 2)$，这不是我们想要的，所以我们需要检测下一个\verb|start|
  和下一个\verb|end|，直到值不相同为止。
\end{example}

再确定好这两个去重条件后，我们就可以写出如下的代码：

\lstinputlisting[language=C++]{code/three_sum.cpp}

在这个问题中，最关键的问题在于理解到二数之和和三数之和并没有本质的区别。其核心的思路是一致
的。解决了这个问题你就可以下面解决这个类似的问题。

\href{https://leetcode.cn/problems/3sum-closest/}{最接近的三数之和
}

\subsection{\href{https://leetcode-cn.com/problems/4sum}{四数之和}}

可能已经有聪明的读者已经明白了如何解决四数之和了。一个最简单的做法就是确定一个数，然后使用
使用三数之和的代码，并根据Example 1.1.1的思路去重即可。这是最显而易见的方法。也就是再添加
一个\verb|for|循环处理就行了。

\begin{kaobox}[title=思考]
我们该如何解决$N$数之和的问题呢？实际上一个最简单的做法就是回溯，对于每一个数来说，我们有两个选择，
选或者不选。这样的时间复杂度是$O(2^n)$。这样也是很慢的，最实际的做法是对于$N$数之和先求解$N-1$
数之和，但是这样似乎我们无法写出代码出来，因为似乎要展开不确定的循环。最简单的做法就是利用元编程
来处理。当然也可以修改成递归来处理。
\end{kaobox}

\end{document}
